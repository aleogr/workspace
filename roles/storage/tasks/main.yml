---
# --- 1. DETECÇÃO DE AMBIENTE (Preservada e Adaptada) ---
# Mantivemos a lógica para saber onde estamos rodando, mas removemos 
# a definição de 'target_disk' para formatação, pois não vamos formatar nada.

- name: Detectar ambiente de virtualização
  ansible.builtin.debug:
    msg: 
      - "Ambiente detectado: {{ ansible_virtualization_role | default('bare-metal') }}"
      - "Modo de Operação: CONFIGURAÇÃO DE SINGLE DISK (Dual Boot Safe)"
      - "O disco do Windows (2TB) será IGNORADO."
      - "Usando pool do sistema: {{ pool_name }}"

# --- 2. VERIFICAÇÃO DE SEGURANÇA ---
- name: Verificar se o Pool {{ pool_name }} (Sistema) está ativo
  ansible.builtin.command: zpool list {{ pool_name }}
  register: pool_check
  # Aqui mudamos a lógica: Se o pool NÃO existir, falhamos.
  # O Proxmox já deve estar instalado neste pool.
  failed_when: pool_check.rc != 0
  changed_when: false

- name: Abortar se o pool do sistema não for encontrado
  ansible.builtin.fail:
    msg: "ERRO CRÍTICO: O pool '{{ pool_name }}' não foi encontrado. O Proxmox foi instalado com ZFS?"
  when: pool_check.rc != 0

# --- 3. DATASETS (Organização) ---
# Criamos datasets para separar VMs e Backups dentro do disco de boot

- name: Criar Datasets Organizacionais
  community.general.zfs:
    name: "{{ item }}"
    state: present
    # Herdamos as propriedades do pool raiz (compressão, etc)
  loop:
    - "{{ pool_name }}/vms"      # Onde ficarão os discos das VMs
    - "{{ pool_name }}/backups"  # Onde o PBS salvará dados

# --- 4. CONFIGURAÇÃO DO STORAGE NO PROXMOX ---

# Verifica se o storage ID já existe no /etc/pve/storage.cfg
- name: Verificar existência do Storage ID {{ storage_id_vm }}
  ansible.builtin.shell: pvesm status | grep -w "{{ storage_id_vm }}"
  register: storage_check
  failed_when: false
  changed_when: false

# Cenário A: Se for o 'local-zfs' padrão, apenas garantimos que ele aceite tudo
- name: Atualizar permissões de conteúdo do 'local-zfs' (Se for o padrão)
  ansible.builtin.command: >
    pvesm set {{ storage_id_vm }} --content images,rootdir,vztmpl,iso,snippets
  when: 
    - storage_check.rc == 0
    - storage_id_vm == "local-zfs"
  changed_when: false

# Cenário B: Se for um nome novo (ex: VM-Storage) e não existir, criamos
- name: Adicionar Novo Storage ZFS ao Proxmox
  ansible.builtin.command: >
    pvesm add zfspool {{ storage_id_vm }} --pool {{ pool_name }}/vms --content images,rootdir --sparse 1
  when: storage_check.rc != 0
  register: pvesm_add
  changed_when: "pvesm_add.rc == 0"

# --- 5. SWAP NO ZFS (Essencial para estabilidade) ---
- name: Configurar Swappiness (Evitar uso excessivo do NVMe)
  ansible.posix.sysctl:
    name: vm.swappiness
    value: '10'
    state: present
    sysctl_file: /etc/sysctl.d/99-pve-swappiness.conf

- name: Verificar se Swap ZFS já existe
  ansible.builtin.command: zfs list {{ pool_name }}/swap
  register: swap_check
  failed_when: false
  changed_when: false

- name: Criar e Ativar Swap ZVol (Se não existir)
  ansible.builtin.shell: |
    # Cria volume de 8GB
    zfs create -V 8G -b $(getconf PAGESIZE) \
      -o compression=zle \
      -o logbias=throughput \
      -o sync=always \
      -o primarycache=metadata \
      -o secondarycache=none \
      -o com.sun:auto-snapshot=false \
      {{ pool_name }}/swap
    
    udevadm settle
    
    # Formata como Swap
    mkswap -f /dev/zvol/{{ pool_name }}/swap
    
    # Ativa
    swapon /dev/zvol/{{ pool_name }}/swap
  when: swap_check.rc != 0

- name: Persistir Swap no Fstab
  ansible.posix.mount:
    path: none
    src: /dev/zvol/{{ pool_name }}/swap
    fstype: swap
    opts: sw
    state: present
